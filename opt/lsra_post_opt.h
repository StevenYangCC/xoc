/*@
Copyright (c) 2013-2021, Su Zhenyu steven.known@gmail.com
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Su Zhenyu nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@*/
#ifndef _LSRA_POST_OPT_H_
#define _LSRA_POST_OPT_H_

namespace xoc {

//
//Start GenTabOfMap.
//
class GenTabOfMap {
    COPY_CONSTRUCTOR(GenTabOfMap);

public:
    GenTabOfMap() {}
    ~GenTabOfMap() {}

    IRTab * createMapped(LifeTime const* lt)
    {
        ASSERT0(lt);
        return new IRTab();
    }
};
//End GenTabOfMap.

typedef xcom::TMap<LifeTime const*, IRTab*,
    CompareKeyBase<LifeTime const*>, GenTabOfMap> LT2IRTab;
typedef xcom::TMapIter<LifeTime const*, IRTab*> LT2IRTabIter;

typedef xcom::TMap<PRNO, IR const*> PR2FakeUseSpill;
typedef xcom::TMapIter<PRNO, IR const*> PR2FakeUseSpillIter;

typedef struct _IRPair {
    IR * spill;
    IR * reload;
} IRPair;
typedef xcom::List<IRPair*> IRPairLst;


//
//Start SpillReloadEliminateMgr
//
class SpillReloadEliminateMgr {
    typedef xcom::TTab<IR const*> RemovedIRTab;
    typedef xcom::TTabIter<IR const*> RemovedIRTabIter;
private:
    COPY_CONSTRUCTOR(SpillReloadEliminateMgr);
    LinearScanRA & m_ra;
    Region * m_rg;

    //Record the spilling IRs and splitting position IR when spilling after
    //definition occurance related to the lifetime in order of occurance.
    LT2IRTab * m_lt2spill;

    //Record spill and reload IR pairs.
    IRPairLst * m_spill_reload_pairs;

    //Map a prno to the related spill IR if the prno is used in the fake-use
    //IR at the first BB of loop in lexicographical order.
    PR2FakeUseSpill m_pr2fakeuse_spill;

    //Store the IRs removed.
    RemovedIRTab m_removed_ir_tab;
protected:
    IRPair * allocIRPair() { return new IRPair(); }
    IRPairLst * allocIRPairLst() { return new IRPairLst(); }
    LT2IRTab * allocLT2IRTab() { return new LT2IRTab(); }
public:
    SpillReloadEliminateMgr(LinearScanRA & ra);
    ~SpillReloadEliminateMgr();

    void addToRemovedIRTab(IR const* ir) { m_removed_ir_tab.append(ir); }

    void freeRemovedIRs();

    LT2IRTab * getLT2Spill() { return m_lt2spill; }
    IRPairLst * getSpillReloadPairs() { return m_spill_reload_pairs; }

    PR2FakeUseSpill const& getPR2FakeUseSpill() const
    { return m_pr2fakeuse_spill; }

    IR const* getSpillAtFirstFakeUse(PRNO prno) const
    {
        ASSERT0(prno!= PRNO_UNDEF);
        bool find = false;
        IR const* spill = m_pr2fakeuse_spill.get(prno, &find);
        ASSERT0(find);
        return spill;
    }

    //Check the IR has been already removed or not.
    bool isIRRemoved(IR const* ir) const
    { ASSERT0(ir); return m_removed_ir_tab.find(ir); }

    //Check the prno is spilled due to fake-use IR or not.
    bool isSpillAtFirstFakeUse(PRNO prno) const
    {
        ASSERT0(prno != PRNO_UNDEF);
        return m_pr2fakeuse_spill.find(prno);
    }

    //Record the spilling and definition IRs related to the lifetime.
    void record(LifeTime const* lt, IR * ir);

    //Record the spill and reload IR pairs.
    void record(IR * spill, IR * reload);

    //Record the spill info generated by fake-use IR.
    void recordInfoUsedByFakeUseSpillElim(LifeTime const* lt, IR const* spill,
                                          IR const* split_pos_ir, bool is_def);

    //Record the spill info for one-def spill elimination.
    void recordInfoUsedByOneDefElim(LifeTime const* lt, IR * spill);

    //Record the inserted latch BBs from LatchMap.
    //latch_map: save the inserted latch BB.
    void recordLatchBBTab(LatchMap const& latch_map);

    void recordSpill(LifeTime const* lt, IR * spill, SplitCtx const& ctx,
                     bool is_def);

    //Record the prno and it's spill IR if the prno is used in the fake-use
    //IR at the first BB of loop in lexicographical order.
    void recordSpillAtFirstFakeUse(PRNO prno, IR const* spill)
    {
        ASSERT0(spill);
        ASSERT0(prno != PRNO_UNDEF);
        m_pr2fakeuse_spill.set(prno, spill);
    }
};
//End SpillReloadEliminateMgr


//
//Start LSRAPostOpt.
//
class LSRAPostOpt {
    COPY_CONSTRUCTOR(LSRAPostOpt);
    typedef xcom::TMap<IRBB*, IRBB*> BB2BB;
protected:
    Region * m_rg;
    LSRAImpl & m_impl;
    LinearScanRA & m_ra;
    RegSetImpl & m_rsimpl;
    BBList * m_bb_list;
    IRCFG * m_cfg;
    OptCtx * m_oc;
    SpillReloadEliminateMgr m_spill_reload_eliminate_mgr;
protected:
    //This function determines whether the current IR can be hoisted out of the
    //given loop, based on the following two conditions:
    //  1. IRs in the loop header cannot be hoisted.
    //  2. The current IR has register/stack conflicts with other IRs, or there
    //     exists call statements that modifie the register in the loop using
    //     `hasRegOrStackSlotConflictOrCallInLoop()`.
    bool canBeHoisted(IR const* ir, LI<IRBB> const* li,
                      MOD ConstIRIter & inneririt);

    //Eliminate each IR in the `irtab`.
    bool eliminateIRsInTab(IRTab & irtab);

    //Eliminate the redundant Mov IRs, which have the same source and
    //destination physical register.
    bool eliminateRedundantMov();

    //Eliminate redundant spill IRs that follow a reload IR and use
    //the same stack slot.
    bool eliminateSameSlotSpillAfterReload();

    //Eliminate extra spilling IRs for one-def lifetimes. Since the split point
    //of the one-def lifetime is not strictly after the definition point, the
    //approach of removing all existing spills and adding a new spill after the
    //definition point is adopted as a replacement.
    bool eliminateSpillOfOneDefLifeTime();

    //Find the outermost loop to which an IR can be hoisted. It ensures that
    //the IR can be safely moved outside the loop without causing register
    //conflicts, stack slot conflicts, or issues with call operations.
    //Key Steps:
    //  1. Retrieve the BB associated with the IR.
    //  2. Find the innermost loop that includes the BB.
    //  3. Traverse the loop hierarchy outward, checking for conflicts at each
    //     level using `canBeHoisted()`.
    //  4. Return the outermost loop where no conflicts are detected.
    LI<IRBB> const* findHoistOuterMostLoop(IR const* ir, LI<IRBB> const* li,
                                           MOD ConstIRIter & inneririt);

    //Generate a new basic block before the loop head to store the IRs to be
    //hoisted outside the loop. The diagram is as follows:
    //
    //  BB0                BB0                     BB0                BB0
    //   |                  |                    ___|___            ___|___
    //   V                  V                   |       |          |       |
    //  BB1 <--     -->    BB3 (new)            V       V          V       V
    //   |    |             |                  BB1     BB2        BB1     BB2
    //   V    |             V                   |_______|          |_______|
    //  BB2 __|            BB1 <--      or:         |                  |
    //                      |    |                  V                  V
    //                      V    |                 BB3 <--     -->    BB5 (new)
    //                     BB2 __|                  |    |             |
    //                                              V    |             V
    //                                             BB4 __|            BB3 <--
    //                                                                 |    |
    //                                                                 V    |
    //                                                                BB4 __|
    IRBB * genBBToHoistSpillReloadOutsideLoop(LI<IRBB> const* li,
        MOD BB2BB & bb2insert, MOD OptCtx & oc);

    //Calculate the number of common IRs at the end of BBs.
    UINT getCommonIRNumsSuffix(Vector<IRBB*> const& bbvec);

    //Find and record the predecessor latch BBs of the current BB.
    //The return value is the number of predecessor latch BBs.
    UINT getPredLatchBB(IRBB const* bb, MOD Vector<IRBB*> & latch_vec);

    //Check whether the given `ir` has register conflict with given `reg`.
    //Key steps:
    //  1. Jugde whether the current IR modifies PR. Exit directly if false.
    //  2. Get the register allocated to the PRNO and compare it with the given
    //     register.
    bool hasRegConflict(IR const* ir, Reg reg);

    //Check whether a given loop contains register conflicts, stack slot
    //conflicts, or call operations that would prevent hoisting an IR outside
    //the loop. Key Steps:
    //  1. Retrieve the register and stack slot information associated with the
    //     IR.
    //  2. Iterate through all BBs in the loop.
    //  3. For each IR in the BBs:
    //     - Check if it is a call statement that modifies the register.
    //     - Check if it causes a register conflict with the given IR.
    //     - Check if it causes a stack slot conflict with the given IR.
    //  4. Return true if any conflict is found; otherwise, return false.
    bool hasRegOrStackSlotConflictOrCallInLoop(
        IR const* ir, LI<IRBB> const* li, MOD ConstIRIter & inneririt);
    bool hasRegOrStackSlotConflictOrCallInLoopBB(
        IR const* ir, IRBB * bb, MOD ConstIRIter & inneririt);

    //Check whether the given `ir` has stack slot conflict with the given
    //`var`. Key step:
    //  1. Traverse the IR tree using an iterator (`ConstIRIter`).
    //  2. For each inner IR node:
    //     - Check if the IR has associated variable information (`hasIdinfo`).
    //     - Retrieve the variable information (`getIdinfo`) and compare it
    //       with the input variable.
    //     - If a match is found, return true to indicate a conflict.
    //  3. If no match is found after traversing the entire IR tree, return
    //     false.
    bool hasStackSlotConflict(IR const* ir, Var const* var,
                              MOD ConstIRIter & it);

    //Hoist reload IRs outside the loop. The diagram is as follows:
    //
    //   ...                               ...
    //    |                                 |
    //    V            1. generate BB3      V
    //   BB1 <-------  --------------->    -BB3------
    //    |         |  2. move spill or    |        |
    //    V         |     reload from      | Spill/ |
    //  -BB2------  |     BB2 to BB3       | Reload |
    //  |        |__|                      |________|
    //  | Spill/ |                          |
    //  | Reload |                          V
    //  |________|                         BB1 <--
    //                                      |    |
    //                                      V    |
    //                                     BB2___|
    //
    bool hoistSpillReloadOutsideLoop(OptCtx & oc);
    bool hoistSpillReloadOutsideLoopImpl(OptCtx & oc, IRTab const& tab);

    bool isDifferentIROp(IR const* ir1, IR const* ir2) const;

    //Return true if the current BB is a tramp BB.
    bool isTrampBB(IRBB const* bb) const
    {
        return bb->getNumOfIR() == 1 && bb->getNumOfPred() == 1 &&
            const_cast<IRBB*>(bb)->getLastIR()->is_goto();
    }

    //Return true if cur_bb is the unique predecessor of succ_bb and succ_bb
    //is the unique successor of cur_bb.
    bool isUniquePredSuccPair(IRBB const* cur_bb, IRBB const* succ_bb) const
    {
        ASSERT0(cur_bb != nullptr && succ_bb != nullptr);
        return m_cfg->isUniquePred(succ_bb, cur_bb) &&
            m_cfg->isUniqueSucc(cur_bb, succ_bb);
    }

    //Merge common IRs at the end of the given BB set.
    //latch_vec: the set of BBs that need to be merged.
    //base_bb: the common successor of all BBs.
    //com_ir_num: the number of IRs to be merged.
    //Select a target BB and use its common IRs as the merged BB (preferably one
    //that fallthrough to the base_bb). Based on the relationship between the
    //number of IRs in the target BB and com_ir_num, handle two different cases.
    //
    //CASE1: the number of IRs in the target BB is greater than com_ir_num.
    //
    //    latch bb1      latch bb2          latch bb1      latch bb2
    //    ---------      ---------          ---------      ---------
    //    |  IR1  |      |  IR1  |  <--     |  IR1  |      |  IR1  |
    //    |  IR2  |      |  IR4  |    |     |  IR2  |      ---------
    //    |  IR4  |      ---------    |     ---------          |
    //    ---------          |   target bb      |              |
    //        |              |                  ----------------
    //        ----------------       ==>               |
    //               |                                 V
    //               V                              new bb
    //            base bb                          ---------
    //           ---------                         |  IR4  |
    //           |  ...  |                         ---------
    //           ---------                             |
    //                                                 V
    //                                              base bb
    //
    //CASE2: the number of IRs in the target BB is equal to com_ir_num.
    //
    //    latch bb1      latch bb2               latch bb1
    //    ---------      ---------               ---------
    //    |  IR1  |      |  IR2  |  <--          |  IR1  |
    //    |  IR2  |      |  IR4  |    |          ---------
    //    |  IR4  |      ---------    |              |
    //    ---------          |   target bb           V
    //        |              |                   latch bb2
    //        ----------------        ==>        ---------
    //               |                           |  IR2  |
    //               V                           |  IR4  |
    //            base bb                        ---------
    //           ---------                           |
    //           |  ...  |                           V
    //           ---------                        base bb
    //
    bool mergeCommonIRAtBlockEnd(Vector<IRBB*> & latch_vec,
                                 MOD IRBB * base_bb, UINT com_ir_num);

    //Optimize common IR sequences at basic block boundaries.
    //When a block has multiple predecessors that all end with the same sequence
    //of move instructions, the moves can be hoisted and placed once at the
    //beginning of the block instead of duplicating them in each predecessor.
    //Similarly, if a block has multiple successors that start with the same
    //sequence of move instructions, these moves can be sunk and placed once at
    //the end of the block to avoid duplication.
    bool optimizeCommonIRAtBBBoundaries();

    //Optimize common IRs at the beginning of multiple successor BBs
    //of the same BB. Common IRs are those that translate to the same
    //machine instruction.
    //e.g:
    //            base bb                           base bb
    //           ---------                         ---------
    //           |  IR0  |                         |  IR0  |
    //           ---------                         |  IR1  |
    //               |                             ---------
    //         --------------        ==>               |
    //        |              |                   -------------
    //        |              |                  |             |
    //        v              v                  v             v
    //       bb1            bb2                bb1           bb2
    //    ---------      ---------          ---------      ---------
    //    |  IR1  |      |  IR1  |          |  IR2  |      |  IR4  |
    //    |  IR2  |      |  IR4  |          |  IR4  |      ---------
    //    |  IR4  |      ---------          ---------
    //    ---------
    //
    bool optimizeCommonIRAtBlockBegin();

    //Optimize common IRs from multiple predecessor latch BBs of the same BB.
    //Common IRs are those that translate to the same machine instruction.
    //e.g:
    //    latch bb1      latch bb2          latch bb1      latch bb2
    //    ---------      ---------          ---------      ---------
    //    |  IR1  |      |  IR1  |          |  IR1  |      |  IR1  |
    //    |  IR2  |      |  IR4  |          |  IR2  |      ---------
    //    |  IR4  |      ---------          ---------          |
    //    ---------          |                  |              |
    //        |              |                  ----------------
    //        ----------------       ==>               |
    //               |                                 V
    //               V                              new bb
    //            base bb                          ---------
    //           ---------                         |  IR4  |
    //           |  ...  |                         ---------
    //           ---------                             |
    //                                                 V
    //                                              base bb
    //
    //NOTE: Currently, only identical IRs at the end of latch BBs are merged.
    //This optimization can be extended in two directions:
    //1.Merge identical IRs at the end of all predecessor BBs and identical
    //  IRs at the start of all successor BBs.
    //2.Analyze whether IRs in latch BBs can be reordered to discover more
    //  opportunities for merging.
    bool optimizeCommonIRAtLatchBBEnd();

    //When the last instruction of the previous BB is a store and the first
    //instruction of the current BB is a load, the load instruction can be
    //weakened to a mov instruction.
    //e.g:
    //   BB1:
    //      ...
    //      st:u64:storage_space(stack) 'var_47'
    //          $1810:u64 (r44)
    //   BB2:
    //      stpr $2506:u64 (r18)
    //          ld:u64:storage_space(stack) 'var_47'
    //      ...
    // ==>
    //   BB1:
    //      ...
    //      st:u64:storage_space(stack) 'var_47'
    //          $1810:u64 (r44)
    //   BB2:
    //      stpr $2506:u64 (r18)
    //          $1810:u64 (r44)
    //      ...
    bool optimizeCrossBBStoreLoadToMov();

    //Promote for the spill and reload IR by registers.
    bool promoteSpillReload(OptCtx & oc);

    //Remove the redundant pos gap IR.
    bool removeRedundantPosGapIR(OptCtx & oc);

    //Remove the unnecessary spill IRs inserted due to fake-use IR.
    bool removeSpillIRForFakeUseAtLexFirstBBOfLoop();

    //Try to replace spill and reload IRs into move operations using available
    //register for different architectures.
    //
    //Before:                                      After:
    //  st:u64:storage_space(stack) 'var'   ---->    stpr $replace:u64
    //    $0:u64                                       $0:u64
    //
    //  ......                                       ......
    //
    //  stpr $1:u64                         ---->    stpr $1:u64
    //    ld:u64:storage_space(stack) 'var'            $replace:u64
    //
    //Note that this optimization should be performed in the same basic block.
    //Since the availabel register may be used for jump operations.
    bool replaceSpillAndReloadToMov();
public:
    LSRAPostOpt(LSRAImpl & impl) : m_rg(impl.getRegion()), m_impl(impl),
        m_ra(impl.getRA()), m_rsimpl(impl.getRegSetImpl()),
        m_spill_reload_eliminate_mgr(impl.getRA())
    {
        m_bb_list = m_ra.getBBList();
        m_cfg = m_rg->getCFG();
    }
    ~LSRAPostOpt() {}

    BBList * getBBList() const { return m_bb_list; }
    LifeTimeMgr & getLTMgr() { return m_ra.getLTMgr(); }
    LinearScanRA & getRA() const { return m_ra; }
    Region * getRegion() const { return m_rg; }
    SpillReloadEliminateMgr & getSpillReloadEliminateMgr()
    { return m_spill_reload_eliminate_mgr; }
    OptCtx * getOptCtx() const { return m_oc; }

    //Eliminate single IR.
    bool eliminateSingleIR(IR const* ir);

    bool perform(OptCtx & oc);
};
//End LSRAPostOpt.


//
//START PosGapIROpt
//
//The PosGapIROpt removes the dead position gap IRs (spill/reload/move/remat)
//inserted during the register allocation after the Def-Use chain analysis.
//The dead spill is a spilling operation which doesn't modify the data of the
//memory, that means this operation is meaningless. The dead reload operation
//is a normal reload operation, but the new loaded value in the register is
//not used by any IR, or a dead spill only, so this reload operation is
//meaningless as well. The dead remat and move IRs are the defined register
//is not used by any IR afterwards.
//
//e.g1 for the dead spill:
// $10 <- reload [x]   //reload
// $12 <- add $10, $1
// [x] <- spill $10    //dead spill
//
//e.g2 for the dead reload:
// $10 <- reload [x]   //dead reload if the next spill IR is a dead spill.
// [x] <- spill $10    //dead spill
//
//e.g3 for the dead reload:
// $10 <- reload [x]   //dead reload if the there is no use of $10 afterwards.
// xx  <- mov $11
//
//e.g4 for the dead move:
// $10 <- mov $30   //dead move if the there is no use of $10 afterwards.
// xx  <- mov $11
//
//e.g5 for the dead remat:
// $10 <- remat 30   //dead remat if the there is no use of $10 afterwards.
// xx  <- mov $11
typedef xcom::TMap<IR const*, bool> IR2BOOL;
class PosGapIROpt {
    COPY_CONSTRUCTOR(PosGapIROpt);
    Region * m_rg;
    LSRAPostOpt * m_post_opt;
    LinearScanRA * m_ra;

    //Used to store the dead spill IRs.
    ConstIRTab m_dead_spill_tab;

    //Used to store the dead reload/remat/mov IRs.
    ConstIRTab m_dead_misc_tab;
public:
    PosGapIROpt(LSRAPostOpt * post_opt) : m_post_opt(post_opt)
    {
        m_rg = post_opt->getRegion();
        m_ra = &post_opt->getRA();
    }

    ~PosGapIROpt() {}

    void addDeadMiscIR(IR const* ir)
    { ASSERT0(ir); m_dead_misc_tab.append(ir); }
    void addDeadSpillIR(IR const* ir)
    { ASSERT0(ir); m_dead_spill_tab.append(ir); }

    void collectDeadMiscIR();
    void collectDeadSpillIR();

    //Generate the Def-Use Info.
    void genDUInfo(OptCtx & oc);

    //This func perform the optimization by the following 4 steps:
    //1.Generate the Def-Use infomation.
    //2.Collect the deal spill IRs.
    //3.Collect the dead reload/remat/move IRs.
    //4.Remove the recorded IRs in step 2 and step 3.
    //Return true if there are some spill/reload/remat/move IRs are removed,
    //otherwise, return false;
    bool perform(OptCtx & oc);

    //Remove the recorded spill and reload IRs.
    void removeDeadIR();
};
//END PosGapIROpt

} //namespace xoc
#endif
