/*@
Copyright (c) 2013-2021, Su Zhenyu steven.known@gmail.com
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Su Zhenyu nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@*/
#ifndef _LSRA_POST_OPT_H_
#define _LSRA_POST_OPT_H_

namespace xoc {

//
//Start GenTabOfMap.
//
class GenTabOfMap {
    COPY_CONSTRUCTOR(GenTabOfMap);

public:
    GenTabOfMap() {}
    ~GenTabOfMap() {}

    IRTab * createMapped(LifeTime const* lt)
    {
        ASSERT0(lt);
        return new IRTab();
    }
};
//End GenTabOfMap.

typedef xcom::TMap<LifeTime const*, IRTab*,
    CompareKeyBase<LifeTime const*>, GenTabOfMap> LT2IRTab;
typedef xcom::TMapIter<LifeTime const*, IRTab*> LT2IRTabIter;

typedef xcom::TMap<PRNO, IR const*> PR2FakeUseSpill;
typedef xcom::TMapIter<PRNO, IR const*> PR2FakeUseSpillIter;

typedef struct _IRPair {
    IR * spill;
    IR * reload;
} IRPair;
typedef xcom::List<IRPair*> IRPairLst;


//
//Start SpillReloadEliminateMgr
//
class SpillReloadEliminateMgr {
    typedef xcom::TTab<IR const*> RemovedIRTab;
    typedef xcom::TTabIter<IR const*> RemovedIRTabIter;
private:
    COPY_CONSTRUCTOR(SpillReloadEliminateMgr);
    LinearScanRA & m_ra;
    Region * m_rg;

    //Record the spilling IRs and splitting position IR when spilling after
    //definition occurance related to the lifetime in order of occurance.
    LT2IRTab * m_lt2spill;

    //Record spill and reload IR pairs.
    IRPairLst * m_spill_reload_pairs;

    //Map a prno to the related spill IR if the prno is used in the fake-use
    //IR at the first BB of loop in lexicographical order.
    PR2FakeUseSpill m_pr2fakeuse_spill;

    //Store the IRs removed.
    RemovedIRTab m_removed_ir_tab;
protected:
    IRPair * allocIRPair() { return new IRPair(); }
    IRPairLst * allocIRPairLst() { return new IRPairLst(); }
    LT2IRTab * allocLT2IRTab() { return new LT2IRTab(); }
public:
    SpillReloadEliminateMgr(LinearScanRA & ra);
    ~SpillReloadEliminateMgr();

    void addToRemovedIRTab(IR const* ir) { m_removed_ir_tab.append(ir); }

    void freeRemovedIRs();

    LT2IRTab * getLT2Spill() { return m_lt2spill; }
    IRPairLst * getSpillReloadPairs() { return m_spill_reload_pairs; }

    PR2FakeUseSpill const& getPR2FakeUseSpill() const
    { return m_pr2fakeuse_spill; }

    IR const* getSpillAtFirstFakeUse(PRNO prno) const
    {
        ASSERT0(prno!= PRNO_UNDEF);
        bool find = false;
        IR const* spill = m_pr2fakeuse_spill.get(prno, &find);
        ASSERT0(find);
        return spill;
    }

    //Check the IR has been already removed or not.
    bool isIRRemoved(IR const* ir) const
    { ASSERT0(ir); return m_removed_ir_tab.find(ir); }

    //Check the prno is spilled due to fake-use IR or not.
    bool isSpillAtFirstFakeUse(PRNO prno) const
    {
        ASSERT0(prno != PRNO_UNDEF);
        return m_pr2fakeuse_spill.find(prno);
    }

    //Record the spilling and definition IRs related to the lifetime.
    void record(LifeTime const* lt, IR * ir);

    //Record the spill and reload IR pairs.
    void record(IR * spill, IR * reload);

    //Record the spill info generated by fake-use IR.
    void recordInfoUsedByFakeUseSpillElim(LifeTime const* lt, IR const* spill,
                                          IR const* split_pos_ir, bool is_def);

    //Record the spill info for one-def spill elimination.
    void recordInfoUsedByOneDefElim(LifeTime const* lt, IR * spill);

    //Record the inserted latch BBs from LatchMap.
    //latch_map: save the inserted latch BB.
    void recordLatchBBTab(LatchMap const& latch_map);

    void recordSpill(LifeTime const* lt, IR * spill, SplitCtx const& ctx,
                     bool is_def);

    //Record the prno and it's spill IR if the prno is used in the fake-use
    //IR at the first BB of loop in lexicographical order.
    void recordSpillAtFirstFakeUse(PRNO prno, IR const* spill)
    {
        ASSERT0(spill);
        ASSERT0(prno != PRNO_UNDEF);
        m_pr2fakeuse_spill.set(prno, spill);
    }
};
//End SpillReloadEliminateMgr


typedef xcom::List<Reg> RegList;
typedef xcom::TTab<Var const*> VarPromoteTab;

//
//START IRGroup
//
#define IRGROUP_weight(g) (g->weight)
#define IRGROUP_reg(g) (g->reg)
#define IRGROUP_tmpvar(g) (g->tmp_var)
#define IRGROUP_orgvar(g) (g->org_var)
class IRGroup {
    COPY_CONSTRUCTOR(IRGroup);
public:
    //Record the weight for the spill and reload IRs in the current group.
    UINT weight;

    //Record the available register can be used to do the promotion.
    Reg reg;

    //Record the original var used for the spill and reload IR.
    Var const* org_var;

    //Record the temp var which used for computing the lifetime of current
    //group.
    Var const* tmp_var;

    //The set of reload and spill IRs.
    IRVec irvec;
public:
    IRGroup(): weight(0), reg(REG_UNDEF), org_var(nullptr), tmp_var(REG_UNDEF)
    {}

    //Add an IR into the current group.
    void addIR(IR const* ir)
    {
        ASSERT0(ir);
        ASSERT0(ir->is_stpr() || ir->is_st());
        irvec.append(const_cast<IR*>(ir));
    }

    void dump(Region * rg) const;

    //Get the number of IR for the current group.
    UINT getIRCnt() const { return irvec.get_elem_count(); }

    IRVec const* getIRVec() const
    { return &irvec; }

    //Modify the var of IR in the group by the input var 'v'.
    void modifyIRVar(Var const* v);

    //Renanem the var of IR to the temp_var.
    void renameIRVar();

    //recover the original var in the IRs of current group.
    void revertIRVar();
};
//END IRGroup

typedef xcom::Vector<IRGroup*> IRGroups;

//
//START VarGroups
//
#define VARGROUPS_has_all(v) (v->m_has_all)
class VarGroups {
    COPY_CONSTRUCTOR(VarGroups);
public:
    //Used to indicate the current groups contain all the spill and reload
    //IRs for the current spill var.
    bool m_has_all;

    //The groups for the spill var.
    IRGroups * m_groups;
public:
    VarGroups() : m_has_all(true)
    {
        m_groups = new IRGroups();
    }
    ~VarGroups()
    {
        if (m_groups != nullptr) { delete m_groups; }
    }

    //Add a new group to the spill var.
    void addGroup(UINT gid, IRGroup * irgp)
    {
        ASSERT0(irgp);
        ASSERT0(m_groups);
        m_groups->set(gid, irgp);
    }

    //Add the input ir to the specified group indicated by the group id.
    void addIRToGroup(UINT gid, IR const* ir)
    {
        ASSERT0(ir);
        ASSERT0(m_groups);
        ASSERT0(m_groups->get(gid));
        m_groups->get(gid)->addIR(ir);
    }

    void dump(Region * rg) const;

    //Get the group number of the spill var.
    UINT getGroupNum() const
    {
        if (m_groups == nullptr) { return 0; }
        return m_groups->get_elem_count();
    }

    //Return the goups of the spill var.
    IRGroup * getIRGroup(UINT idx) const
    {
        if (m_groups == nullptr) { return nullptr; }
        return m_groups->get(idx);
    }

    //Check the groups of this spill var is full group or not. Return true
    //if it has all the spill and reload IRs of the spill var, and also has
    //only one group.
    bool isFullGroup() const
    { return m_has_all && m_groups->get_elem_count() == 1; }
};
//End VarGroups

typedef xcom::TMap<Var const*, VarGroups*> Var2Groups;
typedef xcom::TMapIter<Var const*, VarGroups*> Var2GroupsIter;
typedef xcom::Vector<IRGroup*> IRGroupVec;

//
//START SpillReloadPromote
//
//This class shall promote the spill/reload to the move operation between
//two registers, which helps to enhance the performance of register allocation.
//The basic idea of this algorithm is listed below:
//  1. Group the spill IR and reload IR by a spill var.
//  2. Construct the var lifetime of each group.
//  3. Find an available register to which can accomodate the live range of
//     the spill var for each group by the overview of phisical register
//     lifetime manager. Becasue all the registers has been assigned to the
//     prnos during the previous register allocation, we try to find a hole in
//     the register lifetime to accomodate the liftime of var for each group.
//     e.g1:REG_1 cannot accomodate the lifetime of VAR_1, but the range of
//          VAR_1<30-31> fit the hole of REG_2 well, so we can use the REG_2
//          to replace the spill var VAR_1.
//     LT:VAR_1,range:<30-31>
//      |                             --
//      |                             du

//     LT:REG_1,range:<22-23><24-27><28-43>
//      |                     ----------------------
//      |                     dud  udu             u
//     LT:REG_2,range:<22-23><24-27><35-43>
//      |                     ------      ----------
//      |                     dud  u      d        u
//  4. Use the available physical register to replace the spill/reload IR by
//     the register move operation.
//
//Based on the above idea, in order to decrease the most of the memory access
//introduced by the spill/reload operation, we group the spill/reload IRs of
//a spill var three times in three group modes, and try to find a proper
//register which can eliminate the spill and reload IRs in the group.
//
//Let's explain the three group modes.
//  1. GROUP_MODE_FULL:
//       Group all the spill and reload IRs of a spill var into a big group,
//       find an available register which can replace the spill var for all
//       the spill and reload IRs in the group. That means we can eliminate
//       all the spill reload IRs for this spill var.
//
//  2. GROUP_MOD_PART:
//       Group some of spill and reload IRs for a spill var. Normally the USE
//       of a spill var is reload operation, the DEF of a spill var is spill
//       operation, If we find the USE of a spill var is only from a single
//       DEF, then we group these spill and reload IRs into a group. That
//       means the if the USE of a spill var is shared by multiple DEFs, this
//       reload IR will not be grouped. We use the MDSSA Def-Use chain during
//       the group process.
//
//  3. GROUP_MOD_SINGLE:
//       Group each single DEF and USE of a spill var into a group, we also
//       use the MDSSA Def-Use chain during the group process.
//
//  For a specific spill var, we do the following three steps:
//  1. We do the full group for this var, if the full group can be promoted by
//     register, we will not do the next two steps.
//  2. We do the partial group for this var, usually there may be more than
//     one group in the partial group mode. We try to promote some groups if
//     e. If all these partial groups are promoted, we will not do the
//     next step. In this step, we replace the reload IRs with move IRs, and
//     leave the spill IR there because it is may be needed by other reload
//     IRs.
//  3. We do the single groups for the spill and reload which are not promoted
//     in previous two steps. In this step, we replace the reload IRs with
//     move IRs, and leave the spill IR there because it is may be needed by
//     other reload IRs.
//
//Key data structure used in this class:
//1. IRGroup: Record the an vector of spill/reload IR of a var, and also
//            include the weight, the suitable promoted register for the IRs
//            in the group and var info.
//2. VarGroup:Record all the IR groups of a var, because we have three modes,
//            there may be have more than one group is partial and single
//            group mode.
//3. Var2Groups:Map a var to it's group information.
//                          | ID 1: IRGroup: [IR_1, IR2, ...]
//      var --> VarGroups --| ID 2: IRGroup: [IR_5, IR6, ...]
//                          | ID 3: IRGroup: [IR_3, IR9, ...]
//                          | ...
class SpillReloadPromote {
    COPY_CONSTRUCTOR(SpillReloadPromote);
    enum GROUP_MODE {
        GROUP_MODE_UNDEF = 0,
        GROUP_MODE_FULL = 1,
        GROUP_MODE_PART = 2,
        GROUP_MODE_SINGLE = 3,
    };
    GROUP_MODE m_mode;
    Region * m_rg;
    BBList * m_bb_list;
    LinearScanRA * m_lsra;
    RegSetImpl & m_rsimpl;
    MDSSAMgr * m_mdssamgr;
    List<VarGroups*> m_vargroups_list;
    List<IRGroup*> m_irgroup_list;

    //Full group.
    Var2Groups m_full_groups;
    IRGroupVec m_full_group_vec;

    //Record the full group promotion results.
    VarPromoteTab m_vartab;

    //Single group.
    Var2Groups m_part_groups;
    IRGroupVec m_valid_partial_groups;

    //Single Group.
    Var2Groups m_single_groups;
    IRGroupVec m_valid_single_groups;

    LSRAVarLivenessMgr m_var_liveness_mgr;
    VarLifeTimeMgr m_var_ltmgr;

    //Record the unused spill/reload IRs after promoted by register.
    IRVec m_unused_irs;
public:
    SpillReloadPromote(Region * rg, LinearScanRA * ra, RegSetImpl & rsimpl);
    ~SpillReloadPromote();

    void addToValidPartialGroup(IRGroup * irgp)
    {  ASSERT0(irgp); m_valid_partial_groups.append(irgp); }
    void addToFullGroupVec(IRGroup * irgp)
    {  ASSERT0(irgp); m_full_group_vec.append(irgp); }
    void addToValidSingleGroup(IRGroup * irgp)
    {  ASSERT0(irgp); m_valid_single_groups.append(irgp); }

    void addUnusedIR(IR * ir) { ASSERT0(ir); m_unused_irs.append(ir); }

    IRGroup * allocIRGroup()
    {
        IRGroup * ir_gp = new IRGroup();
        m_irgroup_list.append_tail(ir_gp);
        return ir_gp;
    }

    VarGroups * allocVarGroups()
    {
        VarGroups * var_gps = new VarGroups();
        m_vargroups_list.append_tail(var_gps);
        return var_gps;
    }
    //Calculate the weight for the group, which can be used as the order
    //of group to find the register for promotion, becasue the bigger
    //weight indicates the bigger cost for spill/reload.
    UINT calcWeightForGroup(IRVec const* irvec) const;

    //Destory the resources allocated for the tmp vars.
    void destroyTmpVar();

    //Do the full group.
    void doFullGroup(OptCtx & oc);
    void doFullGroupIR(IR const* ir);

    //Do the partial group.
    void doPartialGroup(OptCtx & oc);

    //Do the single group.
    void doSingleGroup(OptCtx & oc);

    void dump() const;
    void dumpFullGroup() const;
    void dumpPartialGroup() const;
    void dumpSingleGroup() const;

    //Find the register for full group var.
    void findRegForFullGroupVars();

    //Find the register for fpartial group var.
    void findRegForPartialGroupVars();

    //Find the register for single group var.
    void findRegForSingleGroupVars();

    void genDUInfo(OptCtx & oc);

    void genVar2DLifeTime(OptCtx & oc);

    //Generate a new IR group for var.
    //var_groups: point to the var group object.
    //var: the var of the group.
    IRGroup * genIRGroupForVar(MOD VarGroups * var_groups, Var const* var);

    //generate the single var group based on IR group of the partial group.
    //irgp: The IR group of partial group.
    //v: the var of the group.
    void genSingleVarGroupFromPartialIRGroup(IRGroup * irgp, Var const* v);

    //Get the best register to accomodate the specified range.
    //rv: the input range.
    //ty: the required data type when find a available register.
    //best_reg: the best register that can hold the 'rv'.
    //reg_tab: used to store all the availble regs for the 'rv'.
    //return true if any proper register can be found, or else, retun false.
    bool getRegToCoverRange(Range const& tar_range, Type const* reg_ty,
        OUT Reg & best_reg, MOD xcom::TTab<Reg> & reg_tab);

    TargInfoMgr * getTIMgr() const
    { return m_rg->getRegionMgr()->getTargInfoMgr(); }

    //Group the reload IR based on the use-set.
    //useset: the use-set of spill IR.
    //ir_group: the IR group to be filled.
    void groupReloadInUseSet(IRSet const& useset, MOD IRGroup * ir_group);

    //Group the IR in partial group mode.
    void groupIRPartially(IR const* ir, MOD IRSet & useset);

    //Group the IR in single group mode.
    void groupIRSingle(IR const* ir);

    void groupFully();
    void groupPartially();
    void groupSingle();

    //Return the IRGroupVec per the different group mode.
    IRGroupVec * getIRGroups()
    {
        switch (m_mode) {
        case GROUP_MODE_FULL: return &m_full_group_vec;
        case GROUP_MODE_PART: return &m_valid_partial_groups;
        case GROUP_MODE_SINGLE: return &m_valid_single_groups;
        case GROUP_MODE_UNDEF:
        default: ASSERT0(0); return nullptr;
        }
    }

    //Get and generate the IR group in var group for a var.
    //var_groups: the var group.
    //var: the var to be grouped.
    IRGroup * getAndGenIRGroupFromFullGroup(MOD VarGroups * var_groups,
        Var const* var)
    {
        ASSERT0(var_groups);
        ASSERT0(var_groups->getGroupNum() <= 1);
        if (var_groups->getGroupNum() == 1) {
            return var_groups->getIRGroup(0);
        }
        IRGroup * irgp = allocIRGroup();
        IRGROUP_orgvar(irgp) = var;
        var_groups->addGroup(0, irgp);
        return irgp;
    }

    //Return the max group number in all the single groups.
    UINT getMaxSingleGroupNum();

    VarGroups * getAndGenVarFullGroups(Var const* v)
    {
        bool find = false;
        VarGroups * var_groups = m_full_groups.get(v, &find);
        if (!find) {
            var_groups = allocVarGroups();
            m_full_groups.set(v, var_groups);
        }
        return var_groups;
    }
    VarGroups * getAndGenVarPartialGroups(Var const* v)
    {
        bool find = false;
        VarGroups * var_groups = m_part_groups.get(v, &find);
        if (!find) {
            var_groups = allocVarGroups();
            m_part_groups.set(v, var_groups);
        }
        return var_groups;
    }

    VarGroups * getAndGenVarSingleGroups(Var const* v)
    {
        bool find = false;
        VarGroups * var_groups = m_single_groups.get(v, &find);
        if (!find) {
            var_groups = allocVarGroups();
            VARGROUPS_has_all(var_groups) = false;
            m_single_groups.set(v, var_groups);
        }
        return var_groups;
    }

    //Get the best register to accomodate the specified range vector.
    //rv: the input vector of ranges.
    //ty: the required data type when find a available register.
    //best_reg: the best register that can hold the 'rv'.
    //reg_tab: used to store all the availble regs for the 'rv'.
    //return true if any proper register can be found, or else, retun false.
    bool getBestRegToAccommodateRange(RangeVec const& rv, Type const* ty,
        OUT Reg & best_reg, MOD xcom::TTab<Reg> & reg_tab);

    VarLifeTimeMgr & getVarLTMgr() { return m_var_ltmgr; }

    //Return true if the 'v' has been promoted in full group mode.
    bool isPromotedInFullGroup(Var const* v) const
    { return m_vartab.find(v); }

    bool perform(OptCtx & oc);

    //Do the promote for the spill and reload IR for full group mode.
    void promoteSpillReloadFullGroup(OptCtx & oc);

    //Do the promote for the spill and reload IR for partial group mode.
    void promoteSpillReloadPartialGroup(OptCtx & oc);

    //Do the promote for the spill and reload IR for single group mode.
    void promoteSpillReloadSingleGroup(OptCtx & oc);

    //Promote the spill reload for the specified group.
    //gp: the group to be promoted.
    //remove: a flag to indicate the spill IR is removed or not.
    void promoteSpillReloadForGroup(IRGroup * gp, bool remove, OptCtx & oc);

    //Promote the reload IR by a specifed register.
    //cur: the reload IR to be promoted.
    //prno: the src PRNO.
    void promoteReloadOp(IR * cur, PRNO prno);

    //Promote the spill IR by a specifed register.
    //cur: the spill IR to be promoted.
    //prno: the dst PRNO.
    //remove: a flag to indicate the spill IR is removed or not.
    void promoteSpillOp(IR * cur, PRNO prno, bool remove, OptCtx & oc);

    //Record the callee register.
    void recordCallee(Reg r)
    {
        ASSERT0(r != REG_UNDEF);
        if (!m_rsimpl.isCallee(r)) { return; }
        RegSet & calleeset = m_rsimpl.getUsedCallee();
        if (calleeset.is_contain(r)) { return; }
        m_rsimpl.recordUsedCallee(r);
    }

    //Removed the unused spill reload IR.
    void removeUnusedIR(OptCtx & oc);

    //Rename the var of IR for the var liftime computation.
    void renameIRVar();

    //Recover the var of IR.
    void revertIRVar();

    //Set the group mode.
    void setGroupMode(GROUP_MODE mode) { m_mode = mode; }

    //Sort the groups.
    void sortFullGroup();
    void sortPartialGroup();
    void sortSingleGroup(UINT id);

    //Try to assign a register for a group.
    //vid: the group id.
    //irvec: the group of spill reload IR.
    //reg_tab: used to store all the availble regs for a group.
    //return the best suitable register for the group.
    Reg tryAssignRegForGroup(UINT vid, IRVec const* irvec,
        MOD xcom::TTab<Reg> & reg_tab);
};
//END SpillReloadPromote


//
//Start LSRAPostOpt.
//
class LSRAPostOpt {
    COPY_CONSTRUCTOR(LSRAPostOpt);
    typedef xcom::TMap<IRBB*, IRBB*> BB2BB;
protected:
    Region * m_rg;
    LSRAImpl & m_impl;
    LinearScanRA & m_ra;
    RegSetImpl & m_rsimpl;
    BBList * m_bb_list;
    IRCFG * m_cfg;
    OptCtx * m_oc;
    SpillReloadEliminateMgr m_spill_reload_eliminate_mgr;
protected:
    //This function determines whether the current IR can be hoisted out of the
    //given loop, based on the following two conditions:
    //  1. IRs in the loop header cannot be hoisted.
    //  2. The current IR has register/stack conflicts with other IRs, or there
    //     exists call statements that modifie the register in the loop using
    //     `hasRegOrStackSlotConflictOrCallInLoop()`.
    bool canBeHoisted(IR const* ir, LI<IRBB> const* li,
                      MOD ConstIRIter & inneririt);

    //Eliminate each IR in the `irtab`.
    bool eliminateIRsInTab(IRTab & irtab);

    //Eliminate the redundant Mov IRs, which have the same source and
    //destination physical register.
    bool eliminateRedundantMov();

    //Eliminate redundant spill IRs that follow a reload IR and use
    //the same stack slot.
    bool eliminateSameSlotSpillAfterReload();

    //Eliminate extra spilling IRs for one-def lifetimes. Since the split point
    //of the one-def lifetime is not strictly after the definition point, the
    //approach of removing all existing spills and adding a new spill after the
    //definition point is adopted as a replacement.
    bool eliminateSpillOfOneDefLifeTime();

    //Find the outermost loop to which an IR can be hoisted. It ensures that
    //the IR can be safely moved outside the loop without causing register
    //conflicts, stack slot conflicts, or issues with call operations.
    //Key Steps:
    //  1. Retrieve the BB associated with the IR.
    //  2. Find the innermost loop that includes the BB.
    //  3. Traverse the loop hierarchy outward, checking for conflicts at each
    //     level using `canBeHoisted()`.
    //  4. Return the outermost loop where no conflicts are detected.
    LI<IRBB> const* findHoistOuterMostLoop(IR const* ir, LI<IRBB> const* li,
                                           MOD ConstIRIter & inneririt);

    //Generate a new basic block before the loop head to store the IRs to be
    //hoisted outside the loop. The diagram is as follows:
    //
    //  BB0                BB0                     BB0                BB0
    //   |                  |                    ___|___            ___|___
    //   V                  V                   |       |          |       |
    //  BB1 <--     -->    BB3 (new)            V       V          V       V
    //   |    |             |                  BB1     BB2        BB1     BB2
    //   V    |             V                   |_______|          |_______|
    //  BB2 __|            BB1 <--      or:         |                  |
    //                      |    |                  V                  V
    //                      V    |                 BB3 <--     -->    BB5 (new)
    //                     BB2 __|                  |    |             |
    //                                              V    |             V
    //                                             BB4 __|            BB3 <--
    //                                                                 |    |
    //                                                                 V    |
    //                                                                BB4 __|
    IRBB * genBBToHoistSpillReloadOutsideLoop(LI<IRBB> const* li,
        MOD BB2BB & bb2insert, MOD OptCtx & oc);

    //Save the map of reg and it's corresponded lifetime.
    void generateRegLifeTime(OptCtx & oc);

    //Calculate the number of common IRs at the end of BBs.
    UINT getCommonIRNumsSuffix(Vector<IRBB*> const& bbvec);

    //Find and record the predecessor latch BBs of the current BB.
    //The return value is the number of predecessor latch BBs.
    UINT getPredLatchBB(IRBB const* bb, MOD Vector<IRBB*> & latch_vec);

    //Check whether the given `ir` has register conflict with given `reg`.
    //Key steps:
    //  1. Jugde whether the current IR modifies PR. Exit directly if false.
    //  2. Get the register allocated to the PRNO and compare it with the given
    //     register.
    bool hasRegConflict(IR const* ir, Reg reg);

    //Check whether a given loop contains register conflicts, stack slot
    //conflicts, or call operations that would prevent hoisting an IR outside
    //the loop. Key Steps:
    //  1. Retrieve the register and stack slot information associated with the
    //     IR.
    //  2. Iterate through all BBs in the loop.
    //  3. For each IR in the BBs:
    //     - Check if it is a call statement that modifies the register.
    //     - Check if it causes a register conflict with the given IR.
    //     - Check if it causes a stack slot conflict with the given IR.
    //  4. Return true if any conflict is found; otherwise, return false.
    bool hasRegOrStackSlotConflictOrCallInLoop(
        IR const* ir, LI<IRBB> const* li, MOD ConstIRIter & inneririt);
    bool hasRegOrStackSlotConflictOrCallInLoopBB(
        IR const* ir, IRBB * bb, MOD ConstIRIter & inneririt);

    //Check whether the given `ir` has stack slot conflict with the given
    //`var`. Key step:
    //  1. Traverse the IR tree using an iterator (`ConstIRIter`).
    //  2. For each inner IR node:
    //     - Check if the IR has associated variable information (`hasIdinfo`).
    //     - Retrieve the variable information (`getIdinfo`) and compare it
    //       with the input variable.
    //     - If a match is found, return true to indicate a conflict.
    //  3. If no match is found after traversing the entire IR tree, return
    //     false.
    bool hasStackSlotConflict(IR const* ir, Var const* var,
                              MOD ConstIRIter & it);

    //Hoist reload IRs outside the loop. The diagram is as follows:
    //
    //   ...                               ...
    //    |                                 |
    //    V            1. generate BB3      V
    //   BB1 <-------  --------------->    -BB3------
    //    |         |  2. move spill or    |        |
    //    V         |     reload from      | Spill/ |
    //  -BB2------  |     BB2 to BB3       | Reload |
    //  |        |__|                      |________|
    //  | Spill/ |                          |
    //  | Reload |                          V
    //  |________|                         BB1 <--
    //                                      |    |
    //                                      V    |
    //                                     BB2___|
    //
    bool hoistSpillReloadOutsideLoop(OptCtx & oc);
    bool hoistSpillReloadOutsideLoopImpl(OptCtx & oc, IRTab const& tab);

    bool isDifferentIROp(IR const* ir1, IR const* ir2) const;

    //Return true if the current BB is a tramp BB.
    bool isTrampBB(IRBB const* bb) const
    {
        return bb->getNumOfIR() == 1 && bb->getNumOfPred() == 1 &&
            const_cast<IRBB*>(bb)->getLastIR()->is_goto();
    }

    //Return true if cur_bb is the unique predecessor of succ_bb and succ_bb
    //is the unique successor of cur_bb.
    bool isUniquePredSuccPair(IRBB const* cur_bb, IRBB const* succ_bb) const
    {
        ASSERT0(cur_bb != nullptr && succ_bb != nullptr);
        return m_cfg->isUniquePred(succ_bb, cur_bb) &&
            m_cfg->isUniqueSucc(cur_bb, succ_bb);
    }

    //Merge common IRs at the end of the given BB set.
    //latch_vec: the set of BBs that need to be merged.
    //base_bb: the common successor of all BBs.
    //com_ir_num: the number of IRs to be merged.
    //Select a target BB and use its common IRs as the merged BB (preferably one
    //that fallthrough to the base_bb). Based on the relationship between the
    //number of IRs in the target BB and com_ir_num, handle two different cases.
    //
    //CASE1: the number of IRs in the target BB is greater than com_ir_num.
    //
    //    latch bb1      latch bb2          latch bb1      latch bb2
    //    ---------      ---------          ---------      ---------
    //    |  IR1  |      |  IR1  |  <--     |  IR1  |      |  IR1  |
    //    |  IR2  |      |  IR4  |    |     |  IR2  |      ---------
    //    |  IR4  |      ---------    |     ---------          |
    //    ---------          |   target bb      |              |
    //        |              |                  ----------------
    //        ----------------       ==>               |
    //               |                                 V
    //               V                              new bb
    //            base bb                          ---------
    //           ---------                         |  IR4  |
    //           |  ...  |                         ---------
    //           ---------                             |
    //                                                 V
    //                                              base bb
    //
    //CASE2: the number of IRs in the target BB is equal to com_ir_num.
    //
    //    latch bb1      latch bb2               latch bb1
    //    ---------      ---------               ---------
    //    |  IR1  |      |  IR2  |  <--          |  IR1  |
    //    |  IR2  |      |  IR4  |    |          ---------
    //    |  IR4  |      ---------    |              |
    //    ---------          |   target bb           V
    //        |              |                   latch bb2
    //        ----------------        ==>        ---------
    //               |                           |  IR2  |
    //               V                           |  IR4  |
    //            base bb                        ---------
    //           ---------                           |
    //           |  ...  |                           V
    //           ---------                        base bb
    //
    bool mergeCommonIRAtBlockEnd(Vector<IRBB*> & latch_vec,
                                 MOD IRBB * base_bb, UINT com_ir_num);

    //Optimize common IR sequences at basic block boundaries.
    //When a block has multiple predecessors that all end with the same sequence
    //of move instructions, the moves can be hoisted and placed once at the
    //beginning of the block instead of duplicating them in each predecessor.
    //Similarly, if a block has multiple successors that start with the same
    //sequence of move instructions, these moves can be sunk and placed once at
    //the end of the block to avoid duplication.
    bool optimizeCommonIRAtBBBoundaries();

    //Optimize common IRs at the beginning of multiple successor BBs
    //of the same BB. Common IRs are those that translate to the same
    //machine instruction.
    //e.g:
    //            base bb                           base bb
    //           ---------                         ---------
    //           |  IR0  |                         |  IR0  |
    //           ---------                         |  IR1  |
    //               |                             ---------
    //         --------------        ==>               |
    //        |              |                   -------------
    //        |              |                  |             |
    //        v              v                  v             v
    //       bb1            bb2                bb1           bb2
    //    ---------      ---------          ---------      ---------
    //    |  IR1  |      |  IR1  |          |  IR2  |      |  IR4  |
    //    |  IR2  |      |  IR4  |          |  IR4  |      ---------
    //    |  IR4  |      ---------          ---------
    //    ---------
    //
    bool optimizeCommonIRAtBlockBegin();

    //Optimize common IRs from multiple predecessor latch BBs of the same BB.
    //Common IRs are those that translate to the same machine instruction.
    //e.g:
    //    latch bb1      latch bb2          latch bb1      latch bb2
    //    ---------      ---------          ---------      ---------
    //    |  IR1  |      |  IR1  |          |  IR1  |      |  IR1  |
    //    |  IR2  |      |  IR4  |          |  IR2  |      ---------
    //    |  IR4  |      ---------          ---------          |
    //    ---------          |                  |              |
    //        |              |                  ----------------
    //        ----------------       ==>               |
    //               |                                 V
    //               V                              new bb
    //            base bb                          ---------
    //           ---------                         |  IR4  |
    //           |  ...  |                         ---------
    //           ---------                             |
    //                                                 V
    //                                              base bb
    //
    //NOTE: Currently, only identical IRs at the end of latch BBs are merged.
    //This optimization can be extended in two directions:
    //1.Merge identical IRs at the end of all predecessor BBs and identical
    //  IRs at the start of all successor BBs.
    //2.Analyze whether IRs in latch BBs can be reordered to discover more
    //  opportunities for merging.
    bool optimizeCommonIRAtLatchBBEnd();

    //When the last instruction of the previous BB is a store and the first
    //instruction of the current BB is a load, the load instruction can be
    //weakened to a mov instruction.
    //e.g:
    //   BB1:
    //      ...
    //      st:u64:storage_space(stack) 'var_47'
    //          $1810:u64 (r44)
    //   BB2:
    //      stpr $2506:u64 (r18)
    //          ld:u64:storage_space(stack) 'var_47'
    //      ...
    // ==>
    //   BB1:
    //      ...
    //      st:u64:storage_space(stack) 'var_47'
    //          $1810:u64 (r44)
    //   BB2:
    //      stpr $2506:u64 (r18)
    //          $1810:u64 (r44)
    //      ...
    bool optimizeCrossBBStoreLoadToMov();

    //Promote for the spill and reload IR by registers.
    bool promoteSpillReload(OptCtx & oc);

    //Remove the redundant pos gap IR.
    bool removeRedundantPosGapIR(OptCtx & oc);

    //Remove the unnecessary spill IRs inserted due to fake-use IR.
    bool removeSpillIRForFakeUseAtLexFirstBBOfLoop();

    //Try to replace spill and reload IRs into move operations using available
    //register for different architectures.
    //
    //Before:                                      After:
    //  st:u64:storage_space(stack) 'var'   ---->    stpr $replace:u64
    //    $0:u64                                       $0:u64
    //
    //  ......                                       ......
    //
    //  stpr $1:u64                         ---->    stpr $1:u64
    //    ld:u64:storage_space(stack) 'var'            $replace:u64
    //
    //Note that this optimization should be performed in the same basic block.
    //Since the availabel register may be used for jump operations.
    bool replaceSpillAndReloadToMov();
public:
    LSRAPostOpt(LSRAImpl & impl) : m_rg(impl.getRegion()), m_impl(impl),
        m_ra(impl.getRA()), m_rsimpl(impl.getRegSetImpl()),
        m_spill_reload_eliminate_mgr(impl.getRA())
    {
        m_bb_list = m_ra.getBBList();
        m_cfg = m_rg->getCFG();
    }
    ~LSRAPostOpt() {}

    BBList * getBBList() const { return m_bb_list; }
    LifeTimeMgr & getLTMgr() { return m_ra.getLTMgr(); }
    LinearScanRA & getRA() const { return m_ra; }
    Region * getRegion() const { return m_rg; }
    SpillReloadEliminateMgr & getSpillReloadEliminateMgr()
    { return m_spill_reload_eliminate_mgr; }
    OptCtx * getOptCtx() const { return m_oc; }

    //Eliminate single IR.
    bool eliminateSingleIR(IR const* ir);

    bool perform(OptCtx & oc);
};
//End LSRAPostOpt.


//
//START PosGapIROpt
//
//The PosGapIROpt removes the dead position gap IRs (spill/reload/move/remat)
//inserted during the register allocation after the Def-Use chain analysis.
//The dead spill is a spilling operation which doesn't modify the data of the
//memory, that means this operation is meaningless. The dead reload operation
//is a normal reload operation, but the new loaded value in the register is
//not used by any IR, or a dead spill only, so this reload operation is
//meaningless as well. The dead remat and move IRs are the defined register
//is not used by any IR afterwards.
//
//e.g1 for the dead spill:
// $10 <- reload [x]   //reload
// $12 <- add $10, $1
// [x] <- spill $10    //dead spill
//
//e.g2 for the dead reload:
// $10 <- reload [x]   //dead reload if the next spill IR is a dead spill.
// [x] <- spill $10    //dead spill
//
//e.g3 for the dead reload:
// $10 <- reload [x]   //dead reload if the there is no use of $10 afterwards.
// xx  <- mov $11
//
//e.g4 for the dead move:
// $10 <- mov $30   //dead move if the there is no use of $10 afterwards.
// xx  <- mov $11
//
//e.g5 for the dead remat:
// $10 <- remat 30   //dead remat if the there is no use of $10 afterwards.
// xx  <- mov $11
typedef xcom::TMap<IR const*, bool> IR2BOOL;
class PosGapIROpt {
    COPY_CONSTRUCTOR(PosGapIROpt);
    Region * m_rg;
    LSRAPostOpt * m_post_opt;
    LinearScanRA * m_ra;

    //Used to store the dead spill IRs.
    ConstIRTab m_dead_spill_tab;

    //Used to store the dead reload/remat/mov IRs.
    ConstIRTab m_dead_misc_tab;

    //Used to store the dead original remat IRs.
    ConstIRTab m_dead_org_remat_tab;
public:
    PosGapIROpt(LSRAPostOpt * post_opt) : m_post_opt(post_opt)
    {
        m_rg = post_opt->getRegion();
        m_ra = &post_opt->getRA();
    }

    ~PosGapIROpt() {}

    void addDeadMiscIR(IR const* ir)
    { ASSERT0(ir); m_dead_misc_tab.append(ir); }
    void addDeadSpillIR(IR const* ir)
    { ASSERT0(ir); m_dead_spill_tab.append(ir); }
    void addDeadOrgRematIR(IR const* ir)
    { ASSERT0(ir); m_dead_org_remat_tab.append(ir); }

    void collectDeadMiscIR();
    void collectDeadSpillIR();

    //Collect the original IR which can be rematerialized, under some cases
    //the prno defined by original remat IR may have no 'uses' due to the split
    //of the lifetime responding to this prno, so this remat IR can be removed.
    //e.g:
    //  Before split:
    //    $1 <- 64  #S1
    //    ...
    //       <  $1  #S2
    //  After split:
    //    $1 <- 64  #S1
    //    ...
    //    $9 <- 64  #S3
    //       <- $9  #S2
    //  $1 can be rematerialized in #S1, and it is split and renamed to $9,
    //  #S3 is the remat IR inserted by the LSAR, so the definition of $1 in
    //  #S1 is not used anymore in #S2 after split.
    void collectDeadOrgRematIR();

    //Generate the Def-Use Info.
    void genDUInfo(OptCtx & oc);

    //This func perform the optimization by the following 4 steps:
    //1.Generate the Def-Use infomation.
    //2.Collect the deal spill IRs.
    //3.Collect the dead reload/remat/move IRs.
    //4.Remove the recorded IRs in step 2 and step 3.
    //Return true if there are some spill/reload/remat/move IRs are removed,
    //otherwise, return false;
    bool perform(OptCtx & oc);

    //Remove the recorded spill and reload IRs.
    //'oc' is used to remove redudant ir statement.
    void removeDeadIR(OptCtx & oc);
};
//END PosGapIROpt

} //namespace xoc
#endif
